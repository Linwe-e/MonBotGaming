import discord
from discord.ext import commands
import os
import sys
from dotenv import load_dotenv

# Ajouter le dossier utils au path Python
sys.path.append(os.path.join(os.path.dirname(__file__), 'utils'))
sys.path.append(os.path.dirname(__file__))

# Charger les variables secr√®tes
load_dotenv()

# Importer nos configurations et utilitaires
from config import BOT_CONFIG
from utils.ai.gemini_ai import gemini_ai
from utils.discord_helpers.embed_helpers import send_ai_response
from utils.ai.smart_response import SmartResponseManager
from utils.data_management.rgpd_conversation_memory import rgpd_conversation_memory
from utils.discord_helpers.rgpd_consent_ui import show_consent_request

# Configuration du bot
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix=BOT_CONFIG['prefix'], intents=intents)

@bot.event
async def on_ready():
    print(f'üéÆ {bot.user} est connect√© et pr√™t √† gaming!')
    print(f'üìä Connect√© √† {len(bot.guilds)} serveur(s)')
    # Cogs will be loaded by setup_hook

@bot.event
async def on_message(message):
    """Gestionnaire pour les mentions directes du bot"""
    print(f"[DEBUG] on_message triggered: author={message.author}, content='{message.content}'")
    # Ignorer les messages du bot lui-m√™me
    if message.author == bot.user:
        return
    
    # V√©rifier si le bot est mentionn√©
    if bot.user in message.mentions:
        # Extraire le contenu du message sans la mention
        content = message.content
        # Supprimer la mention du bot du message
        for mention in message.mentions:
            if mention == bot.user:
                content = content.replace(f'<@{mention.id}>', '').replace(f'<@!{mention.id}>', '')
        
        content = content.strip()
        print(f"[DEBUG] Bot mention detected. Content after mention strip: '{content}'")
        # Si il y a du contenu apr√®s la mention, traiter comme une question IA
        if content:
            try:
                if gemini_ai.is_available():
                    # V√©rifier le consentement RGPD
                    has_consent, _ = rgpd_conversation_memory.check_user_consent(message.author.id)
                    
                    # Si pas de consentement, v√©rifier si on doit demander ou traiter sans m√©moire
                    if not has_consent:
                        # On cr√©e un contexte "artificiel" pour pouvoir envoyer un message √©ph√©m√®re
                        ctx = await bot.get_context(message)
                        consent_requested = await show_consent_request(ctx, bot, message)
                        
                        # Si on n'a pas pu/voulu demander le consentement (refus r√©cent), 
                        # traiter la question SANS m√©moire
                        if not consent_requested:
                            # Traiter la question sans m√©moire conversationnelle
                            print(f"[DEBUG] Traitement sans m√©moire pour utilisateur ayant refus√©: '{content}'")
                            
                            # Analyser le contexte pour d√©terminer le type de r√©ponse
                            use_embed, embed_type = SmartResponseManager.should_use_embed(content)
                            
                            # G√©n√©rer une r√©ponse IA SANS contexte
                            response = await gemini_ai.gaming_assistant(content, game_context="")
                            
                            # Utiliser la fonction centralis√©e pour envoyer la r√©ponse
                            await send_ai_response(message, content, response, use_embed, embed_type)
                        
                        return
                    
                    # Ajouter le message de l'utilisateur √† la m√©moire (si consentement)
                    rgpd_conversation_memory.add_message(message.author.id, content)
                    
                    print(f"[DEBUG] About to call SmartResponseManager.should_use_embed with content: '{content}'")
                    # Analyser le contexte pour d√©terminer le type de r√©ponse
                    use_embed, embed_type = SmartResponseManager.should_use_embed(content)
                    print(f"[DEBUG] should_use_embed: use_embed={use_embed}, embed_type={embed_type}, content='{content}'")
                    
                    # R√©cup√©rer le contexte de conversation
                    context_list = rgpd_conversation_memory.get_conversation_context(message.author.id)
                    context = "\n".join(context_list) if context_list else ""
                    
                    # G√©n√©rer une r√©ponse adapt√©e selon le type
                    if not use_embed and any(word in content.lower() for word in ['salut', 'bonjour', 'hello', 'hi']):
                        # Salutation simple
                        response = f"Salut {message.author.mention} ! üéÆ"
                        await message.reply(response)
                        
                    elif embed_type == 'privacy_info':
                        print(f"[DEBUG] Bloc RGPD activ√© pour: {content}")
                        privacy_response = (
                            f"[MBG-RGPD] Salut {message.author.mention} ! Je suis l√† pour t'aider avec tes questions gaming. "
                            "Concernant tes donn√©es et ta confidentialit√©, voici comment je fonctionne:\n\n"
                            "**Consentement RGPD :** Je ne stocke tes conversations et ton consentement que si tu as explicitement donn√© ton accord via notre syst√®me RGPD. "
                            "Ceci est fait pour am√©liorer la pertinence de mes r√©ponses en me souvenant du contexte de nos √©changes.\n\n"
                            "**Donn√©es stock√©es :** Je garde une trace de ton consentement et un historique anonymis√© de nos conversations. "
                            "Je ne stocke aucune information personnelle identifiable (comme ton nom Discord, ton adresse e-mail, etc.). "
                            "Tes identifiants de jeu ou autres informations sensibles ne sont jamais enregistr√©s.\n\n"
                            "**Gestion de tes donn√©es :** Tu peux v√©rifier ton statut de consentement ou demander la suppression de tes donn√©es de conversation √† tout moment. "
                            "Utilise les commandes d√©di√©es pour cela (par exemple, `!rgpd status` pour voir ton consentement, ou `!rgpd delete` pour supprimer tes donn√©es).\n\n"
                            "Mon objectif est de t'offrir la meilleure assistance gaming tout en respectant ta vie priv√©e. üéÆ"
                        )
                        await message.reply(privacy_response)
                        return

                    else:
                        # Questions gaming et autres ‚Üí Utiliser la fonction centralis√©e
                        response = await gemini_ai.gaming_assistant(content, game_context=context)
                        await send_ai_response(message, content, response, use_embed, embed_type, context)
                    
                    # Sauvegarder la r√©ponse du bot (si consentement et si response d√©finie)
                    if 'response' in locals():
                        rgpd_conversation_memory.add_message(
                            message.author.id, 
                            response[:200] + "..." if len(response) > 200 else response, 
                            is_bot=True
                        )
                    
                else:
                    # Simple message d'erreur sans embed pour l'IA indisponible
                    await message.reply("ü§ñ L'assistant gaming n'est pas disponible pour le moment. Essaie `!ai status` pour plus d'infos.")
                    
            except discord.HTTPException as e:
                print(f"Erreur Discord lors de la mention IA: {e}")
                await message.reply("‚ùå Une erreur de communication avec Discord est survenue. Veuillez r√©essayer plus tard.")
            except Exception as e:
                print(f"Erreur inattendue lors de la mention IA: {e}")
                await message.reply("üéÆ Oups ! Une erreur inattendue s'est produite. L'assistant gaming est temporairement indisponible. Nous travaillons √† r√©soudre le probl√®me !")
                
        else:
            # Mention sans contenu = salutation simple SANS embed
            await message.reply(f"üéÆ Salut {message.author.mention} ! Besoin d'aide gaming ?")
    
    # Traiter les commandes normales
    await bot.process_commands(message)

async def setup_hook():
    """Hook d'initialisation asynchrone pour charger les cogs"""
    await load_cogs()

bot.setup_hook = setup_hook

@bot.command()
async def hello(ctx):
    await ctx.send(f'Salut **{ctx.author.name}** ! üéÆ Pr√™t pour du gaming ?')

@bot.command()
async def ping(ctx):
    latency = round(bot.latency * 1000)
    await ctx.send(f'üèì Pong! Latence: {latency}ms')

# Charger les cogs (modules)
async def load_cogs():
    """Charge automatiquement tous les cogs disponibles dans le dossier 'cogs'"""
    for filename in os.listdir('./cogs'):
        if filename.endswith('.py') and not filename.startswith('__'):
            try:
                await bot.load_extension(f'cogs.{filename[:-3]}')
                print(f"‚úÖ Module {filename[:-3]} charg√©")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur chargement du module {filename[:-3]}: {e}")

# Gestion des erreurs
@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        await ctx.send("‚ùå Commande inconnue ! Tape `!help` pour voir les commandes disponibles.")
    else:
        print(f"Erreur: {error}")

# Lancer le bot
if __name__ == "__main__":
    token = os.getenv('DISCORD_TOKEN')
    if not token:
        print("‚ùå ERREUR: Token Discord manquant ! Assure-toi qu'il est d√©fini dans le fichier .env ou comme variable d'environnement syst√®me.")
    else:
        print("üöÄ D√©marrage du bot...")
        bot.run(token)
