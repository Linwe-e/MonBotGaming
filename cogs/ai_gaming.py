# ü§ñ Cog IA Gaming pour MonBotGaming
# Commandes utilisant Gemini AI pour l'assistance gaming

import discord
from discord.ext import commands
import sys
import os

# Ajouter utils au path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'utils'))

from config import GAMES
from utils.gaming_helpers import gaming_helpers
from utils.gemini_ai import gemini_ai

class AIGaming(commands.Cog):
    """
    Module IA Gaming - Assistant intelligent pour tes jeux
    Inspir√© de l'architecture modulaire de Rhodham96/DiscordBot
    """
    
    def __init__(self, bot):
        self.bot = bot
    
    @commands.group(name='ai', invoke_without_command=True)
    async def ai_commands(self, ctx):
        """Commandes IA Gaming - !ai help pour voir les options"""
        embed = gaming_helpers.create_gaming_embed(
            title="ü§ñ Assistant IA Gaming",
            description="Utilise Gemini AI pour t'aider dans tes jeux !",
            color='info'
        )
        
        if not gemini_ai.is_available():
            embed.add_field(
                name="‚ö†Ô∏è Configuration requise",
                value="Configure ta cl√© Gemini API dans le fichier .env",
                inline=False
            )
        
        commands_text = """
        **!ai ask [question]** - Pose une question gaming
        **!ai build [jeu] [description]** - Analyse un build
        **!ai team [jeu] [activit√©] [joueurs]** - Composition d'√©quipe
        **!ai event [jeu] [type] [d√©tails]** - Description d'√©v√©nement
        **!ai status** - Statut de l'IA
        """
        
        embed.add_field(
            name="üìã Commandes disponibles",
            value=commands_text,
            inline=False
        )
        
        await ctx.send(embed=embed)
    
    @ai_commands.command(name='ask')
    async def ai_ask(self, ctx, *, question: str):
        """Pose une question √† l'assistant gaming - !ai ask [question]"""
        
        # D√©tecter le contexte de jeu dans le message
        game_id, game_data = gaming_helpers.parse_game_from_message(question)
        game_context = game_data['name'] if game_data else None
        
        embed = gaming_helpers.create_gaming_embed(
            title="ü§ñ Assistant Gaming",
            color='info',
            game=game_id if game_data else None
        )
        
        # Afficher la question (avec limite pour √©viter les erreurs)
        question_display = question[:900] + "..." if len(question) > 900 else question
        embed.add_field(
            name="‚ùì Question",
            value=f"```{question_display}```",
            inline=False
        )
        
        # Traitement en cours
        thinking_msg = await ctx.send(embed=embed)
        
        # G√©n√©rer la r√©ponse
        response = await gemini_ai.gaming_assistant(question, game_context)
        
        # Gestion intelligente des r√©ponses longues
        max_embed_length = 1000  # Marge de s√©curit√© sous la limite Discord de 1024
        
        if len(response) <= max_embed_length:
            # R√©ponse courte : utiliser l'embed
            embed.add_field(
                name="üí° R√©ponse IA",
                value=response,
                inline=False
            )
            
            if game_context:
                embed.add_field(
                    name="üéÆ Contexte d√©tect√©",
                    value=f"{game_data['emoji']} {game_context}",
                    inline=True
                )
            
            await thinking_msg.edit(embed=embed)
        else:
            # R√©ponse longue : utiliser un message texte s√©par√©
            if game_context:
                embed.add_field(
                    name="üéÆ Contexte d√©tect√©",
                    value=f"{game_data['emoji']} {game_context}",
                    inline=True
                )
            
            embed.add_field(
                name="üí° R√©ponse IA",
                value="*R√©ponse d√©taill√©e ci-dessous*",
                inline=False
            )
            
            await thinking_msg.edit(embed=embed)
            
            # Diviser la r√©ponse en chunks si n√©cessaire (limite Discord : 2000 caract√®res par message)
            chunks = []
            current_chunk = ""
            
            for line in response.split('\n'):
                if len(current_chunk) + len(line) + 1 > 1900:  # Marge de s√©curit√©
                    if current_chunk:
                        chunks.append(current_chunk.strip())
                    current_chunk = line
                else:
                    current_chunk += '\n' + line if current_chunk else line
            
            if current_chunk:
                chunks.append(current_chunk.strip())
            
            # Envoyer les chunks
            for i, chunk in enumerate(chunks):
                prefix = f"**Partie {i+1}/{len(chunks)}:**\n" if len(chunks) > 1 else ""
                await ctx.send(f"{prefix}{chunk}")

    @ai_commands.command(name='build')
    async def ai_build(self, ctx, game: str = None, *, description: str = None):
        """Analyse un build pour un jeu - !ai build [jeu] [description]"""
        
        if not description:
            embed = gaming_helpers.create_gaming_embed(
                title="‚ö†Ô∏è Param√®tres manquants",
                description="Usage: `!ai build [jeu] [description du build]`",
                color='warning'
            )
            await ctx.send(embed=embed)
            return
        
        game_id, game_data = gaming_helpers.parse_game_from_message(f"{game} {description}")
        
        embed = gaming_helpers.create_gaming_embed(
            title="üîß Analyse de Build",
            color='info',
            game=game_id if game_data else None
        )
        
        embed.add_field(
            name="üìù Description",
            value=f"```{description}```",
            inline=False
        )
        
        thinking_msg = await ctx.send(embed=embed)
          # Analyser le build
        response = await gemini_ai.analyze_build(description, game or (game_data['name'] if game_data else None))
        
        # Gestion des r√©ponses longues comme pour ai_ask
        max_embed_length = 1000
        
        if len(response) <= max_embed_length:
            embed.add_field(
                name="üí° Analyse IA",
                value=response,
                inline=False
            )
            await thinking_msg.edit(embed=embed)
        else:
            embed.add_field(
                name="üí° Analyse IA",
                value="*Analyse d√©taill√©e ci-dessous*",
                inline=False
            )
            await thinking_msg.edit(embed=embed)
            
            # Diviser en chunks
            chunks = []
            current_chunk = ""
            
            for line in response.split('\n'):
                if len(current_chunk) + len(line) + 1 > 1900:
                    if current_chunk:
                        chunks.append(current_chunk.strip())
                    current_chunk = line
                else:
                    current_chunk += '\n' + line if current_chunk else line
            
            if current_chunk:
                chunks.append(current_chunk.strip())
            
            for i, chunk in enumerate(chunks):
                prefix = f"**Partie {i+1}/{len(chunks)}:**\n" if len(chunks) > 1 else ""
                await ctx.send(f"{prefix}{chunk}")

    @ai_commands.command(name='team')
    async def ai_team(self, ctx, game: str = None, activity: str = None, *, players: str = None):
        """Composition d'√©quipe - !ai team [jeu] [activit√©] [joueurs]"""
        
        if not activity or not players:
            embed = gaming_helpers.create_gaming_embed(
                title="‚ö†Ô∏è Param√®tres manquants",
                description="Usage: `!ai team [jeu] [activit√©] [description des joueurs]`",
                color='warning'
            )
            await ctx.send(embed=embed)
            return
        
        game_id, game_data = gaming_helpers.parse_game_from_message(f"{game} {activity}")
        
        embed = gaming_helpers.create_gaming_embed(
            title="üë• Composition d'√âquipe",
            color='info',
            game=game_id if game_data else None
        )
        
        embed.add_field(name="üéØ Activit√©", value=activity, inline=True)
        embed.add_field(name="üë§ Joueurs", value=players, inline=True)
        
        thinking_msg = await ctx.send(embed=embed)
        
        response = await gemini_ai.suggest_team_composition(game or (game_data['name'] if game_data else None), activity, players)
        
        # Gestion des r√©ponses longues
        max_embed_length = 1000
        
        if len(response) <= max_embed_length:
            embed.add_field(
                name="üí° Suggestions IA",
                value=response,
                inline=False
            )
            await thinking_msg.edit(embed=embed)
        else:
            embed.add_field(
                name="üí° Suggestions IA",
                value="*Suggestions d√©taill√©es ci-dessous*",
                inline=False
            )
            await thinking_msg.edit(embed=embed)
            
            # Diviser en chunks
            chunks = []
            current_chunk = ""
            
            for line in response.split('\n'):
                if len(current_chunk) + len(line) + 1 > 1900:
                    if current_chunk:
                        chunks.append(current_chunk.strip())
                    current_chunk = line
                else:
                    current_chunk += '\n' + line if current_chunk else line
            
            if current_chunk:
                chunks.append(current_chunk.strip())
            
            for i, chunk in enumerate(chunks):
                prefix = f"**Partie {i+1}/{len(chunks)}:**\n" if len(chunks) > 1 else ""
                await ctx.send(f"{prefix}{chunk}")

    @ai_commands.command(name='event')
    async def ai_event(self, ctx, game: str = None, event_type: str = None, *, details: str = None):
        """Description d'√©v√©nement gaming - !ai event [jeu] [type] [d√©tails]"""
        
        if not event_type:
            embed = gaming_helpers.create_gaming_embed(
                title="‚ö†Ô∏è Param√®tres manquants",
                description="Usage: `!ai event [jeu] [type] [d√©tails]`",
                color='warning'
            )
            await ctx.send(embed=embed)
            return
        
        game_id, game_data = gaming_helpers.parse_game_from_message(f"{game} {event_type}")
        
        embed = gaming_helpers.create_gaming_embed(
            title="üéâ √âv√©nement Gaming",
            color='info',
            game=game_id if game_data else None
        )
        
        embed.add_field(name="üìÖ Type", value=event_type, inline=True)
        if details:
            embed.add_field(name="üìù D√©tails", value=details[:500], inline=False)
        
        thinking_msg = await ctx.send(embed=embed)
        
        response = await gemini_ai.generate_event_description(game or (game_data['name'] if game_data else None), event_type, {'title': details} if details else {})
        
        # Gestion des r√©ponses longues
        max_embed_length = 1000
        
        if len(response) <= max_embed_length:
            embed.add_field(
                name="üí° Description IA",
                value=response,
                inline=False
            )
            await thinking_msg.edit(embed=embed)
        else:
            embed.add_field(
                name="üí° Description IA",
                value="*Description d√©taill√©e ci-dessous*",
                inline=False
            )
            await thinking_msg.edit(embed=embed)
            
            # Diviser en chunks
            chunks = []
            current_chunk = ""
            
            for line in response.split('\n'):
                if len(current_chunk) + len(line) + 1 > 1900:
                    if current_chunk:
                        chunks.append(current_chunk.strip())
                    current_chunk = line
                else:
                    current_chunk += '\n' + line if current_chunk else line
            
            if current_chunk:
                chunks.append(current_chunk.strip())
            
            for i, chunk in enumerate(chunks):
                prefix = f"**Partie {i+1}/{len(chunks)}:**\n" if len(chunks) > 1 else ""
                await ctx.send(f"{prefix}{chunk}")

    @ai_commands.command(name='status')
    async def ai_status(self, ctx):
        """Afficher le statut de l'IA"""
        embed = gaming_helpers.create_gaming_embed(
            title="ü§ñ Statut de l'IA",
            color='info'
        )
        
        if gemini_ai.is_available():
            embed.add_field(
                name="‚úÖ Statut",
                value="Gemini AI connect√© et pr√™t",
                inline=False
            )
            embed.add_field(
                name="üîß Mod√®le",
                value="gemini-2.0-flash-exp (Gratuit)",
                inline=True
            )
            embed.add_field(
                name="üéÆ Sp√©cialisation",
                value="Assistant Gaming",
                inline=True
            )
        else:
            embed.add_field(
                name="‚ùå Statut",
                value="IA non configur√©e",
                inline=False
            )
            embed.add_field(
                name="‚öôÔ∏è Configuration",
                value="Ajoute ta cl√© Gemini dans .env",
                inline=False
            )
        
        await ctx.send(embed=embed)

async def setup(bot):
    """Fonction setup pour charger le cog"""
    await bot.add_cog(AIGaming(bot))
